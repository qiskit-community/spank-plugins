# QRMI Task Runner

QRMI Task Runner is an executable to run a quantum workload on the specified QPU resource. This is designed to be used in a Slurm job, configuration parameters such as endpoint URL and access credentials are taken from the process environment variables. Users can run a quantum workload in the form of Qiskit Primitive input([EstimatorV2](https://github.com/Qiskit/ibm-quantum-schemas/blob/main/schemas/estimator_v2_schema.json), [SamplerV2](https://github.com/Qiskit/ibm-quantum-schemas/blob/main/schemas/sampler_v2_schema.json)) for IBM Direct Access or Qiskit Runtime Service, or [Pulser Sequence](https://pulser.readthedocs.io/en/stable/tutorials/serialization.html) for Pascal Cloud. 

This executable receives SIGCONT/SIGTERM signals sent by Slurm infrastructure and cancels the running quantum workload.

## Supported OS

* Linux
  * AlmaLinux 9
  * Amazon Linux 2023
  * CentOS Stream 9
  * CentOS Stream 10
  * RedHat Enterprise Linux 8
  * RedHat Enterprise Linux 9
  * RedHat Enterprise Linux 10
  * Rocky Linux 8
  * Rocky Linux 9
  * SuSE 15
  * Ubuntu 22.04
  * Ubuntu 24.04

* macOS
  * Sequoia 15.1 or above

## Prerequisites

* Rust 1.85.1 or above


## How to build
```shell-session
. ~/.cargo/env
cargo clean
cargo build --release
```

## How to run

```shell-session
$ ./target/release/qrmi_task_runner --help
qrmi_task_runner - Command to run a QRMI task

Usage: qrmi_task_runner [OPTIONS] <name> <file>

Arguments:
  <name>  QPU resource name
  <file>  Input to QPU resource

Options:
  -o, --output <file>  Write output to <file> instead of stdout
  -h, --help           Print help
  -V, --version        Print version
```

### Preparing input payload

JSON schema definition is available in [qrmi_payload_v1_schema.json](./qrmi_payload_v1_schema.json).

#### Example - IBM Direct Access & Qiskit Runtime Service

```json
{
   "parameters": {"pubs": [["OPENQASM 3.0;\ninclude \"stdgates.inc\";\nrz(1.5707963267948966)...\n"]], "version": 2, "options": {"default_shots": 5000}},
   "program_id": "estimator"
}
```

Sample input files can be generated by [the tools](./examples/qiskit).
 
#### Example - Pasqal Cloud

```json
{
   "sequence": {"version": "1", "name": "Sequence_with_defaults", "register": [{"name": "control..."}]},
   "job_runs": 1000
}
```

### Running QRMI task runner from Slurm job script

* The QPU resource name specified for qrmi_task_runner must be one of those specified with the `--qpu` option. In the following example, 2 QPU resources are defined(`ibm_torino` and `ibm_marrakesh`) in the --qpu option, and one of them(`ibm_marrakesh`) is specified for qrmi_task_runner.
* The argument of qrmi_task_runner must be specified according to the resource type corresponding to that QPU resource. If `ibm_marrakesh` was defined as `qiskit-runtime-service` in `qrmi_config.json`, must specify `--input` and `--program-id`.
* The environment variables required for execution are set by the [spank_qrmi](../../plugins/spank_qrmi) and [spank_qrmi_supp](../../plugins/spank_qrmi_supp) plug-ins.
* By default, task results are output to stdout and written to the `slurm-N.out` file; if `--output <file>` is specified as qrmi_task_runner arguments, results are written to that file.

#### IBM Direct Access or Qiskit Runtime Service

Run estimator primitive on ibm_marrakesh.

```shell-session
#!/bin/bash

#SBATCH --job-name=qrmi_job
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=1
#SBATCH --qpu=ibm_torino,ibm_marrakesh

srun /shared/spank-plugins/commands/task_runner/target/release/qrmi_task_runner ibm_marrakesh /shared/input/estimator_input.json
```


#### Pasqal Cloud

Run Pulser sequence on FRESNEL.

```shell-session
#!/bin/bash

#SBATCH --job-name=qrmi_job
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=1
#SBATCH --qpu=FRESNEL

srun ./target/release/qrmi_task_runner FRESNEL /shared/input/sequence_input_FRESNEL.json
```

### Run locally for your testing 

You can run qrmi_task_runner on your host locally for your development or testing by specifying parameters via environment variable setting like below.

#### IBM Direct Access

| Environment variables | Descriptions |
| ---- | ---- |
| SLURM_JOB_QPU_RESOURCES | Quantum backend name |
| SLURM_JOB_QPU_TYPES | Should be `direct-access` |
| {backend_name}_QRMI_IBM_DA_ENDPOINT | Direct Access endpoint URL |
| {backend_name}_QRMI_IBM_DA_IAM_ENDPOINT | IBM Cloud IAM endpoint URL(e.g. `https://iam.cloud.ibm.com`) |
| {backend_name}_QRMI_IBM_DA_IAM_APIKEY | IBM Cloud IAM API Key |
| {backend_name}_QRMI_IBM_DA_SERVICE_CRN | Cloud Resource Name(CRN) of the provisioned Direct Access instance, starting with `crn:v1:`. |
| {backend_name}_QRMI_IBM_DA_AWS_ACCESS_KEY_ID | AWS Access Key ID to access S3 bucket |
| {backend_name}_QRMI_IBM_DA_AWS_SECRET_ACCESS_KEY | AWS Secret Access Key to access S3 bucket |
| {backend_name}_QRMI_IBM_DA_S3_ENDPOINT | S3 endpoint URL |
| {backend_name}_QRMI_IBM_DA_S3_BUCKET | S3 bucket name |
| {backend_name}_QRMI_IBM_DA_S3_REGION | S3 bucket region name(e.g. `us-east`) |
| {backend_name}_QRMI_JOB_TIMEOUT_SECONDS | Time (in seconds) after which job should time out and get cancelled. It is based on system execution time (not wall clock time). System execution time is the amount of time that the system is dedicated to processing your job. |

Example:

```shell-session
export SLURM_JOB_QPU_RESOURCES=test_heron
export SLURM_JOB_QPU_TYPES=direct-access
export test_heron_QRMI_IBM_DA_ENDPOINT=http://localhost:8080
export test_heron_QRMI_IBM_DA_IAM_ENDPOINT=https://iam.cloud.ibm.com
export test_heron_QRMI_IBM_DA_IAM_APIKEY=<your API key>
export test_heron_QRMI_IBM_DA_SERVICE_CRN=<your instance>
export test_heron_QRMI_IBM_DA_AWS_ACCESS_KEY_ID=<your AWS access key ID>
export test_heron_QRMI_IBM_DA_AWS_SECRET_ACCESS_KEY=<your AWS secret access key>
export test_heron_QRMI_IBM_DA_S3_ENDPOINT=https://s3.us-east.cloud-object-storage.appdomain.cloud
export test_heron_QRMI_IBM_DA_S3_REGION=us-east
export test_heron_QRMI_IBM_DA_S3_BUCKET=<your bucket name>
export test_heron_QRMI_JOB_TIMEOUT_SECONDS=3600

./target/release/qrmi_task_runner test_heron /shared/input/estimator_input.json
```

#### Qiskit Runtime Service

| Environment variables | Descriptions |
| ---- | ---- |
| SLURM_JOB_QPU_RESOURCES | Quantum backend name |
| SLURM_JOB_QPU_TYPES | Should be `qiskit-runtime-service` |
| {backend_name}_QRMI_IBM_QRS_ENDPOINT | Qiskit Runtime Service endpoint URL(e.g. `https://quantum.cloud.ibm.com/api`) |
| {backend_name}_QRMI_IBM_QRS_IAM_ENDPOINT | IBM Cloud IAM endpoint URL(e.g. `https://iam.cloud.ibm.com`) |
| {backend_name}_QRMI_IBM_QRS_IAM_APIKEY | IBM Cloud IAM API Key |
| {backend_name}_QRMI_IBM_QRS_SERVICE_CRN | Cloud Resource Name(CRN) of the provisioned Qiskit Runtime Service instance, starting with `crn:v1:`. |
| {backend_name}_QRMI_IBM_QRS_TIMEOUT_SECONDS | (Optional) Cost of the job as the estimated time it should take to complete (in seconds). Should not exceed the cost of the program, default: `None`. |

Example:

```shell-session
export SLURM_JOB_QPU_RESOURCES=ibm_marrakesh
export SLURM_JOB_QPU_TYPES=qiskit-runtime-service
export test_heron_QRMI_IBM_QRS_ENDPOINT=https://quantum.cloud.ibm.com/api
export test_heron_QRMI_IBM_QRS_IAM_ENDPOINT=https://iam.cloud.ibm.com
export test_heron_QRMI_IBM_QRS_IAM_APIKEY=<your API key>
export test_heron_QRMI_IBM_QRS_SERVICE_CRN=<your instance>

./target/release/qrmi_task_runner ibm_marrakesh /shared/input/estimator_input.json
```

#### Pasqal Cloud

| Environment variables | Descriptions |
| ---- | ---- |
| SLURM_JOB_QPU_RESOURCES | Backend name |
| SLURM_JOB_QPU_TYPES | Should be `pasqal-cloud` |
| <backend_name>_QRMI_PASQAL_CLOUD_PROJECT_ID |  Pasqal Cloud Project ID to access the QPU |
| <backend_name>_QRMI_PASQAL_CLOUD_AUTH_TOKEN | Pasqal Cloud Auth Token |

Example:

```shell-session
export SLURM_JOB_QPU_RESOURCES=FRESNEL
export SLURM_JOB_QPU_TYPES=pasqal-cloud
export FRESNEL_QRMI_PASQAL_CLOUD_PROJECT_ID=<your project ID>
export FRESNEL_QRMI_PASQAL_CLOUD_AUTH_TOKEN=<your auth token>

./target/release/qrmi_task_runner FRESNEL /shared/input/sequence_input_FRESNEL.json
```

## Contributing

Regardless if you are part of the core team or an external contributor, welcome and thank you for contributing to QRMI implementations!

### Solving linting/format issues

Contributor must execute the commands below and fix any issues before submitting Pull Request.

#### Rust code
```shell-session
$ . ~/.cargo/env
$ cargo fmt --all -- --check
$ cargo clippy --all-targets -- -D warnings
```
