/*
 * Qiskit Runtime API
 *
 * The Qiskit Runtime API description
 *
 * The version of the OpenAPI document: 0.21.2
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::Deserialize;
use std::time::{SystemTime, UNIX_EPOCH};
use std::cmp::max;

#[derive(Deserialize)]
struct TokenResponse {
    access_token: String,
    expiration: u64,
    expires_in: u64,
}

/// Returns the current Unix timestamp in seconds.
fn current_unix_timestamp() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs()
}

/// Returns a bearer token along with its expiration timestamp and computed lifetime (in seconds).
///
/// The JSON response is expected to include:
///   "access_token": "ACCESS_TOKEN",
///   "expiration": 1616750582,
///   "expires_in": 3600
pub async fn fetch_access_token(
    api_key: &str,
    iam_endpoint: &str,
) -> Result<(String, u64, u64), reqwest::Error> {
    let client = reqwest::Client::new();
    let params = [
        ("grant_type", "urn:ibm:params:oauth:grant-type:apikey"),
        ("apikey", api_key),
    ];

    let response = client
        .post(format!("{}/identity/token", iam_endpoint))
        .header("Content-Type", "application/x-www-form-urlencoded")
        .form(&params)
        .send()
        .await?
        .error_for_status()?; // returns error if HTTP status is not a success

    let token_response: TokenResponse = response.json().await?;
    Ok((
        token_response.access_token,
        token_response.expiration,
        token_response.expires_in,
    ))
}

/// Checks whether the current token is valid based on its remaining lifetime.
///
/// It uses two conditions:
/// 1. The remaining lifetime is less than 360 seconds.
/// 2. The remaining lifetime is less than 10% of the token's computed lifetime.
///
/// If either condition is met, it fetches a new token and updates the provided references.
pub async fn check_token(
    api_key: &str,
    iam_endpoint: &str,
    current_token: &mut Option<String>,
    token_expiration: &mut u64,
    token_lifetime: &mut u64,
) -> Result<(), reqwest::Error> {
    let now = current_unix_timestamp();

    // Both token_expiration and now is u64, and token_expiration may be smaller than now.
    // (token_expiration - now) must cause unexpected wrap around behavior.
    if *token_expiration < now + max(360, *token_lifetime / 10) {
        let (new_token, new_expiration, new_lifetime) =
            fetch_access_token(api_key, iam_endpoint).await?;
        *current_token = Some(new_token);
        *token_expiration = new_expiration;
        *token_lifetime = new_lifetime;
    }
    Ok(())
}
